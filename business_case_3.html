<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Business Case 3: Live Event Traffic Management</title>
  <style>
    :root {
      --color-bg: #f4f4f7;
      --color-text: #1c1f26;
      --color-accent: #0d47a1;
      --color-highlight: #ffffff;
      --color-muted: #607d8b;
      --color-shadow: rgba(0, 0, 0, 0.06);
      --primary-shade: #0a2e6e;
      --border-radius: 10px;
      --section-bg: #e9edf2;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Montserrat', sans-serif;
    }

    body {
      background: linear-gradient(-45deg, #e9edf2, #f4f4f7, #dce3ea, #eef1f4);
      background-size: 400% 400%;
      animation: gradientFlow 15s ease infinite;
      color: var(--color-text);
      line-height: 1.8;
      padding: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 2rem;
      background: rgba(255, 255, 255, 0.75);
      backdrop-filter: blur(6px);
      border-radius: var(--border-radius);
      box-shadow: 0 6px 20px var(--color-shadow);
    }

    h1 {
      font-size: 2.5rem;
      color: var(--color-accent);
      text-align: center;
      margin-bottom: 2rem;
      border-bottom: 2px solid #ddd;
      padding-bottom: 0.8rem;
    }

    h2 {
      font-size: 1.8rem;
      color: var(--primary-shade);
      margin: 2rem 0 1rem;
    }

    h3 {
      font-size: 1.4rem;
      color: var(--color-text);
      margin: 1.5rem 0 1rem;
    }

    p {
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
    }

    ul {
      list-style-type: disc;
      padding-left: 2rem;
      margin-bottom: 1.5rem;
    }

    li {
      font-size: 1.1rem;
      margin-bottom: 0.8rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
    }

    th, td {
      padding: 1rem;
      border: 1px solid #ddd;
      text-align: left;
      font-size: 1.1rem;
    }

    th {
      background-color: var(--color-accent);
      color: white;
    }

    td {
      background-color: #f9f9f9;
    }

    pre {
      background: #f8f8f8;
      padding: 12px;
      border-left: 4px solid var(--color-accent);
      overflow-x: auto;
      font-size: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    @keyframes gradientFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <h1>Live Event Traffic Management</h1>

    <p>
      This business case focuses on optimizing the flow of vehicles and pedestrians during large-scale live events, such as concerts, sports matches, or festivals, to minimize congestion, ensure safety, and enhance attendee experience. The approach leverages real-time traffic data, road capacities, and dynamic rerouting to manage inflows/outflows, prioritize emergency vehicles, and adapt to changing conditions.
    </p>
    <h2>Theory</h2>
    <p>
      Live Event Traffic Management involves coordinating vehicle and pedestrian flows in a road network surrounding event venues to prevent congestion and ensure safety. The road network is modeled as a directed graph, where nodes represent intersections or zones (e.g., parking lots, entrances) and edges represent roads with capacity constraints (e.g., vehicles per minute). Real-time data from sensors, GPS, and traffic cameras informs dynamic routing decisions, maximizing throughput while respecting capacity limits. Algorithms like Ford-Fulkerson optimize flow by finding paths with available capacity, while others, like Traffic Assignment, balance loads across routes to minimize travel times. Prioritizing emergency vehicles requires reserving capacity or computing dedicated routes. Key considerations include adapting to sudden changes (e.g., accidents, road closures), ensuring scalability for thousands of vehicles, and maintaining safety by avoiding bottlenecks and crowd surges. Effective traffic management reduces delays, enhances accessibility, and improves the overall event experience.
    </p>
    <h2>Real-Time Scenario</h2>
    <p>
      During a Super Bowl event in Chicago, thousands of vehicles converge on the stadium from multiple highways, while pedestrians stream toward entrances. The traffic management system models the road network as a graph, with intersections as nodes and roads as edges, each assigned a capacity limit (vehicles per minute). Real-time data from sensors and GPS feeds into the system, which computes optimal traffic flows and routes, directing vehicles to underutilized roads or parking zones to prevent congestion. For instance, as heavy traffic builds on main highways, the system reroutes vehicles to secondary roads, ensuring smoother flow. Emergency vehicles, like ambulances, are prioritized with reserved road capacities or faster routes, allowing rapid access to the venue. When a sudden road closure occurs due to an accident, the system instantly recomputes flows, redirecting traffic to alternative paths to avoid bottlenecks. Parking spaces are allocated efficiently based on real-time availability, and crowd surges are managed by adjusting pedestrian and vehicle flows dynamically, maintaining safety and accessibility throughout the event.
    </p>
    <h2>Usage</h2>
    <p>
      For Akamai, Live Event Traffic Management can be adapted to optimize digital traffic during high-demand online events, such as live-streamed concerts or sports broadcasts, while also supporting physical event logistics for clients. Key use cases include:
    </p>
    <ul>
      <li><strong>Live Streaming Optimization</strong>: Managing millions of concurrent viewers by routing requests to underutilized edge servers, ensuring low-latency streaming.</li>
      <li><strong>Event Venue Traffic Control</strong>: Coordinating vehicle and pedestrian flows for clients hosting physical events, like sports or music festivals, to minimize congestion.</li>
      <li><strong>Emergency Response Support</strong>: Prioritizing critical data flows (e.g., security alerts) or physical emergency vehicle routes during events.</li>
      <li><strong>Parking and Crowd Management</strong>: Allocating parking spaces and controlling pedestrian inflows/outflows to enhance safety and accessibility.</li>
      <li><strong>Real-Time Analytics</strong>: Providing insights on traffic patterns to optimize future event planning and resource allocation.</li>
    </ul>

    <h2>Impact </h2>
    <p>
      Implementing Live Event Traffic Management provides significant benefits for Akamai’s clients and operations:
    </p>
    <ul>
      <li><strong>Reduced Congestion</strong>: Optimizing traffic flows cuts average travel times by 30-50%, improving attendee satisfaction at physical events.</li>
      <li><strong>Enhanced Digital Performance</strong>: Ensuring 99.99% uptime and low-latency streaming for online events boosts viewer engagement by 20-30%.</li>
      <li><strong>Improved Safety</strong>: Prioritizing emergency vehicles and managing crowd surges reduces incident response times by 40%, enhancing event security.</li>
      <li><strong>Cost Efficiency</strong>: Minimizing server load during digital events and optimizing physical traffic reduces operational costs by 15-25%.</li>
      <li><strong>Market Differentiation</strong>: Offering integrated digital and physical traffic management strengthens Akamai’s position as a leader in event solutions.</li>
    </ul>
    <h2>Challenges</h2>
    <ul>
      <li>Dynamic conditions: Real-time changes in traffic, road closures, or weather require rapid adaptation.</li>
      <li>Capacity constraints: Roads and parking lots have limited throughput, risking congestion.</li>
      <li>Emergency prioritization: Ensuring clear paths for ambulances or police vehicles.</li>
      <li>Scalability: Managing thousands of vehicles across complex road networks.</li>
      <li>Safety: Minimizing delays and preventing accidents in high-density scenarios.</li>
    </ul>

    <h2>Algorithms Used</h2>
    <p>Below are the algorithms evaluated for live event traffic management, with summaries of their purpose and detailed explanations of their mechanics, followed by simplified implementations:</p>

    <h2>Ford-Fulkerson (Edmonds-Karp)</h2>
    <p>
      This algorithm maximizes vehicle throughput in a road network by finding the optimal flow of traffic from entry points to the event venue, respecting road capacity limits, using a breadth-first search approach.
    </p>
    <h3>How It Works</h3>
    <p>
      This algorithm, using the Edmonds-Karp variant, maximizes traffic flow through a road network modeled as a graph, where intersections are nodes and roads are edges with capacity limits (vehicles per minute). It employs Breadth-First Search (BFS) to find augmenting paths—routes from the source (entry points) to the sink (venue) with available capacity. For each path, the algorithm sends the maximum possible flow (limited by the smallest capacity along the path), updating residual capacities to reflect the flow used. This process repeats until no augmenting paths remain, ensuring the maximum number of vehicles can reach the venue without exceeding road limits. In practice, this means rerouting traffic to less congested roads in real-time, such as directing vehicles to secondary routes during a festival when main roads are saturated. The algorithm also supports prioritizing emergency vehicles by reserving capacity on specific edges, ensuring faster routes.
    </p>
    <pre>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_NODES 100
#define INF 1000000

typedef struct {
    int from, to;
    int capacity;
} Edge;

int bfs(int** residual, int* parent, int source, int sink, int numNodes) {
    memset(parent, -1, numNodes * sizeof(int));
    int visited[MAX_NODES] = {0};
    int queue[MAX_NODES], front = 0, rear = 0;
    queue[rear++] = source;
    visited[source] = 1;
    
    while (front < rear) {
        int u = queue[front++];
        for (int v = 0; v < numNodes; v++) {
            if (!visited[v] && residual[u][v] > 0) {
                parent[v] = u;
                visited[v] = 1;
                queue[rear++] = v;
                if (v == sink) return 1;
            }
        }
    }
    return 0;
}

int fordFulkerson(int** graph, int source, int sink, int numNodes) {
    int** residual = (int**)malloc(numNodes * sizeof(int*));
    for (int i = 0; i < numNodes; i++) {
        residual[i] = (int*)malloc(numNodes * sizeof(int));
        for (int j = 0; j < numNodes; j++) residual[i][j] = graph[i][j];
    }
    
    int parent[MAX_NODES], maxFlow = 0;
    
    while (bfs(residual, parent, source, sink, numNodes)) {
        int pathFlow = INF;
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            pathFlow = pathFlow < residual[u][v] ? pathFlow : residual[u][v];
        }
        
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            residual[u][v] -= pathFlow;
            residual[v][u] += pathFlow;
        }
        maxFlow += pathFlow;
    }
    
    for (int i = 0; i < numNodes; i++) free(residual[i]);
    free(residual);
    return maxFlow;
}

int main() {
    int numNodes = 7;
    int** graph = (int**)malloc(numNodes * sizeof(int*));
    for (int i = 0; i < numNodes; i++) {
        graph[i] = (int*)calloc(numNodes, sizeof(int));
    }
    
    // Graph: Source (0), Intersections (1-5), Sink (6)
    graph[0][1] = 50; graph[0][2] = 40; graph[1][3] = 30; graph[2][3] = 20;
    graph[2][4] = 25; graph[3][5] = 35; graph[4][5] = 15; graph[5][6] = 45;
    
    printf("Ford-Fulkerson (Edmonds-Karp) Simulation:\n");
    int maxFlow = fordFulkerson(graph, 0, 6, numNodes);
    printf("Maximum traffic flow to venue: %d vehicles/min\n", maxFlow);
    
    for (int i = 0; i < numNodes; i++) free(graph[i]);
    free(graph);
    return 0;
}
    </pre>

    <h2>Min-Cut Max-Flow</h2>
    <p>
      This algorithm extends Ford-Fulkerson to maximize traffic flow and identify critical road bottlenecks that limit vehicle throughput to the event venue, aiding in congestion mitigation planning.
    </p>
    <h3>How It Works</h3>
    <p>
      Building on Ford-Fulkerson (Edmonds-Karp), this algorithm not only computes the maximum flow but also identifies the minimum cut—the smallest set of roads (edges) that, if blocked, would prevent additional vehicles from reaching the venue. After calculating the maximum flow using BFS to find augmenting paths, a final BFS on the residual graph marks nodes reachable from the source. Edges connecting these reachable nodes to unreachable ones form the min-cut, highlighting critical bottlenecks, such as overused intersections or narrow roads. In a real-world scenario, this helps planners identify which roads need capacity upgrades or traffic signal adjustments to prevent congestion during events. For example, during a concert, it might reveal that a single bridge to the venue is the limiting factor, prompting temporary traffic controls or rerouting strategies.
    </p>
    <pre>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_NODES 100
#define INF 1000000

typedef struct {
    int from, to;
    int capacity;
} Edge;

int bfs(int** residual, int* visited, int source, int numNodes) {
    memset(visited, 0, numNodes * sizeof(int));
    int queue[MAX_NODES], front = 0, rear = 0;
    queue[rear++] = source;
    visited[source] = 1;
    
    while (front < rear) {
        int u = queue[front++];
        for (int v = 0; v < numNodes; v++) {
            if (!visited[v] && residual[u][v] > 0) {
                queue[rear++] = v;
                visited[v] = 1;
            }
        }
    }
    return visited[source];
}

int minCutMaxFlow(int** graph, int source, int sink, int numNodes, Edge* cutEdges, int* cutSize) {
    int** residual = (int**)malloc(numNodes * sizeof(int*));
    for (int i = 0; i < numNodes; i++) {
        residual[i] = (int*)malloc(numNodes * sizeof(int));
        for (int j = 0; j < numNodes; j++) residual[i][j] = graph[i][j];
    }
    
    int parent[MAX_NODES], maxFlow = 0;
    while (bfs(residual, parent, source, numNodes)) {
        int pathFlow = INF;
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            pathFlow = pathFlow < residual[u][v] ? pathFlow : residual[u][v];
        }
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            residual[u][v] -= pathFlow;
            residual[v][u] += pathFlow;
        }
        maxFlow += pathFlow;
    }
    
    int visited[MAX_NODES];
    bfs(residual, visited, source, numNodes);
    
    *cutSize = 0;
    for (int u = 0; u < numNodes; u++) {
        if (visited[u]) {
            for (int v = 0; v < numNodes; v++) {
                if (!visited[v] && graph[u][v] > 0) {
                    cutEdges[*cutSize].from = u;
                    cutEdges[*cutSize].to = v;
                    cutEdges[*cutSize].capacity = graph[u][v];
                    (*cutSize)++;
                }
            }
        }
    }
    
    for (int i = 0; i < numNodes; i++) free(residual[i]);
    free(residual);
    return maxFlow;
}

int main() {
    int numNodes = 7;
    int** graph = (int**)malloc(numNodes * sizeof(int*));
    for (int i = 0; i < numNodes; i++) {
        graph[i] = (int*)calloc(numNodes, sizeof(int));
    }
    
    // Graph: Source (0), Intersections (1-5), Sink (6)
    graph[0][1] = 50; graph[0][2] = 40; graph[1][3] = 30; graph[2][3] = 20;
    graph[2][4] = 25; graph[3][5] = 35; graph[4][5] = 15; graph[5][6] = 45;
    
    Edge cutEdges[MAX_NODES * MAX_NODES];
    int cutSize;
    
    printf("Min-Cut Max-Flow Simulation:\n");
    int maxFlow = minCutMaxFlow(graph, 0, 6, numNodes, cutEdges, &cutSize);
    printf("Maximum traffic flow to venue: %d vehicles/min\n", maxFlow);
    printf("Min-Cut edges (bottlenecks):\n");
    for (int i = 0; i < cutSize; i++) {
        printf("Edge %d->%d (Capacity: %d)\n", cutEdges[i].from, cutEdges[i].to, cutEdges[i].capacity);
    }
    
    for (int i = 0; i < numNodes; i++) free(graph[i]);
    free(graph);
    return 0;
}
    </pre>

    <h2>Traffic Assignment Algorithm</h2>
    <p>
      This algorithm balances traffic across multiple routes to achieve user equilibrium, ensuring no driver can reduce travel time by switching paths, accounting for congestion effects.
    </p>
    <h3>How It Works</h3>
    <p>
      This algorithm seeks user equilibrium, where vehicles are distributed across routes so no driver can reduce their travel time by switching paths. The road network is modeled as a graph, with edges having base travel times and capacities. Travel times increase with congestion, calculated using a formula that accounts for flow relative to capacity. The algorithm iteratively applies Dijkstra’s algorithm to find the shortest (fastest) paths from source to sink, assigning a fraction of the traffic demand to these paths. After each iteration, edge flows are updated, and travel times are recalculated to reflect increased congestion, gradually balancing traffic across multiple routes. For example, during a festival, it ensures vehicles spread across main and secondary roads, preventing any single route from becoming overly congested. The process converges after several iterations, achieving a stable distribution of traffic that minimizes overall delays.
    </p>
    <pre>
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#define MAX_NODES 100
#define INF DBL_MAX

typedef struct {
    int from, to;
    double capacity;
    double flow;
    double baseTime;
} Edge;

typedef struct {
    int id;
    double distance;
} PQNode;

void swap(PQNode* a, PQNode* b) {
    PQNode temp = *a;
    *a = *b;
    *b = temp;
}

void heapify(PQNode* pq, int size, int i) {
    int smallest = i, left = 2 * i + 1, right = 2 * i + 2;
    if (left < size && pq[left].distance < pq[smallest].distance) smallest = left;
    if (right < size && pq[right].distance < pq[smallest].distance) smallest = right;
    if (smallest != i) {
        swap(&pq[i], &pq[smallest]);
        heapify(pq, size, smallest);
    }
}

void push(PQNode* pq, int* size, int id, double distance) {
    pq[*size].id = id;
    pq[*size].distance = distance;
    int i = (*size)++;
    while (i > 0 && pq[(i - 1) / 2].distance > pq[i].distance) {
        swap(&pq[i], &pq[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

PQNode pop(PQNode* pq, int* size) {
    PQNode result = pq[0];
    pq[0] = pq[--(*size)];
    heapify(pq, *size, 0);
    return result;
}

double getTravelTime(Edge* edge) {
    return edge->baseTime * (1.0 + 0.15 * (edge->flow / edge->capacity));
}

void dijkstra(Edge* edges, int numEdges, int numNodes, int source, int sink, int* parent) {
    double distances[MAX_NODES];
    PQNode pq[MAX_NODES];
    int pqSize = 0;
    
    for (int i = 0; i < numNodes; i++) distances[i] = INF;
    distances[source] = 0;
    push(pq, &pqSize, source, 0);
    
    while (pqSize > 0) {
        PQNode current = pop(pq, &pqSize);
        int u = current.id;
        if (distances[u] < current.distance) continue;
        
        for (int i = 0; i < numEdges; i++) {
            if (edges[i].from == u) {
                int v = edges[i].to;
                double weight = getTravelTime(&edges[i]);
                if (distances[u] + weight < distances[v]) {
                    distances[v] = distances[u] + weight;
                    parent[v] = u;
                    push(pq, &pqSize, v, distances[v]);
                }
            }
        }
    }
}

void trafficAssignment(Edge* edges, int numEdges, int numNodes, int source, int sink, double totalDemand) {
    int iterations = 10; // Simplified for convergence
    double stepSize = 0.1;
    
    for (int iter = 0; iter < iterations; iter++) {
        int parent[MAX_NODES];
        dijkstra(edges, numEdges, numNodes, source, sink, parent);
        
        double pathFlow = totalDemand * stepSize;
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            for (int i = 0; i < numEdges; i++) {
                if (edges[i].from == u && edges[i].to == v) {
                    edges[i].flow += pathFlow;
                    break;
                }
            }
        }
        
        for (int i = 0; i < numEdges; i++) {
            edges[i].flow = edges[i].flow * (1 - stepSize) + pathFlow * stepSize;
        }
    }
}

int main() {
    int numNodes = 7, numEdges = 8;
    Edge edges[] = {
        {0, 1, 50, 0, 5}, {0, 2, 40, 0, 6}, {1, 3, 30, 0, 4}, {2, 3, 20, 0, 3},
        {2, 4, 25, 0, 5}, {3, 5, 35, 0, 4}, {4, 5, 15, 0, 3}, {5, 6, 45, 0, 6}
    };
    
    double totalDemand = 100; // Vehicles/min entering the network
    printf("Traffic Assignment Simulation:\n");
    trafficAssignment(edges, numEdges, numNodes, 0, 6, totalDemand);
    
    printf("Edge flows after equilibrium:\n");
    for (int i = 0; i < numEdges; i++) {
        printf("Edge %d->%d: Flow = %.2f vehicles/min, Travel Time = %.2f min\n",
               edges[i].from, edges[i].to, edges[i].flow, getTravelTime(&edges[i]));
    }
    
    return 0;
}
    </pre>

    <h2>Time and Space Complexity</h2>
    <table>
      <tr>
        <th>Algorithm</th>
        <th>Best Case Time</th>
        <th>Typical Case Time</th>
        <th>Worst Case Time</th>
        <th>Space Complexity</th>
      </tr>
      <tr>
        <td>Ford-Fulkerson (Edmonds-Karp)</td>
        <td>O(E)</td>
        <td>O(V * E^2)</td>
        <td>O(V * E^2)</td>
        <td>O(V + E)</td>
      </tr>
      <tr>
        <td>Min-Cut Max-Flow</td>
        <td>O(E)</td>
        <td>O(V * E^2)</td>
        <td>O(V * E^2)</td>
        <td>O(V + E)</td>
      </tr>
      <tr>
        <td>Traffic Assignment</td>
        <td>O(E * log V)</td>
        <td>O(I * E * log V)</td>
        <td>O(I * E * log V)</td>
        <td>O(V + E)</td>
      </tr>
    </table>
    <p>
      Note: V = number of vertices (intersections/zones), E = number of edges (roads), I = number of iterations (Traffic Assignment). Ford-Fulkerson and Min-Cut Max-Flow have high worst-case complexity, while Traffic Assignment depends on iteration count.
    </p>

    <h2>Inference</h2>
    <p>
      For Live Event Traffic Management, Ford-Fulkerson (Edmonds-Karp) is the recommended algorithm. It excels in optimizing dynamic traffic flow by maximizing vehicle throughput while respecting road capacities, making it ideal for real-time rerouting to avoid bottlenecks during events like concerts or sports matches. Min-Cut Max-Flow is a close second, offering similar flow optimization with the added benefit of identifying critical congestion points for predictive control. Traffic Assignment Algorithm is effective for achieving equilibrium in multi-path routing but is less adaptable to rapid changes due to its iterative nature. Ford-Fulkerson’s ability to handle live capacity constraints ensures efficient, safe traffic management for large-scale events.
    </p>
  </div>
</body>
</html>